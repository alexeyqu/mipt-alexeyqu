ДЗ 5 -- модели памяти

Куликов Алексей, гр. 397

Задача 1. TATAS spinlock
[tatas-spinlock]

Проанализируйте поведение TATAS spinlock с точки зрения протокола когерентности кэшей MESI:

A) В ситуации, когда на захваченный спинлок накидываются N потоков и пытаются захватить его: почему в этом случае TATAS спинлок предпочтительнее TAS спинлока?

B) В ситуации, когда N потоков крутятся на чтении locked.load(), а поток, владевший спинлоком, освобождает его: locked.store(false).

Решение:

Протокол MESI подразумевает, что для любой пары кэшей валидны комбинации I-<any>, либо S-S.

I -- т.е. эта кэш-линия сейчас не используется.
S -- неблокирующее хранение участка, совпадающего с main memory (с возможностью в любой момент перейти в I, либо в M).
Ещё есть M (Modified) и E (Exclusive).

А) Рассмотрим TATAS. Предположим, что каждый поток крутится на своём процессоре и
что использование памяти достаточно мало, чтобы cache hit случался всегда, когда это возможно.
А ещё предположим, что кэши write-back.

Тогда каждый поток действует так:
1) TAS -- это подгружает в кэш участок с флажком,
  затем выполняет TSL REGISTER, LOCK (т.е. обновляет значение (I --> M state)),
  после этого в момент write-back надо валидировать изменения (пусть и мнимые), что порождает трафик в шине. Тем временем, (M --> S).
2) в цикле происходит locked.load(), что лишь переводит кэш-линию из S в себя же (PrRd), а эти операции не требуют перезаписывать значения в остальных кэшах,
  т.к. подразумевают clean states, что ведёт к отсутствию трафика на шине до тех пор, пока флажок не освободится (Б).

В случае TAS кэш-линии постоянно синхронизируются (пункт 1 TATAS), и трафик никуда не девается.
I --> M --> S --> M --> S --> . . .
Или даже хуже: поскольку M state подразумевает эксклюзивный доступ к памяти, происходит что-то вроде:
I --> M --> S --> I (здесь другие потоки перехватывают TAS-попытки) --> M --> S --> I (и снова) --> . . . (ТРАФИК! каждый раз при I --> <any>)

Б) Пусть поток А: locked.store(false)

Его кэш-линия с флагом переходит в M state. После write-back о значении флага узнают остальные треды.
Это заставляет остальные кэши перевести её в Invalid state (поскольку The cache line is present only in the current cache).

После этого какой-то из N крутящихся в locked.load() тредов получает управление первым.
PrRd заставляет переподгрузить участок памяти из main memory (I --> S), в котором флажок уже изменён на false.

Дальше (возможно, другой) тред-счастливчик пытается провести locked.exchange(true), переводя свою линию в M, и сбрасывая в I линии остальных тредов.
Кому-то это удаётся, линия из этого треда записывается в память (write-back), после чего память читается остальными тредами (I --> S), они обламываются и продолжают крутиться в load-цикле.
