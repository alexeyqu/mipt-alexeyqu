ДЗ 1 -- Алгоритмы взаимного исключения

Куликов Алексей, гр. 397

2) Ticket Spinlock [ticket] - 3 балла

Ticket spinlock с помощью атомарного счетчика выстраивает потоки в очередь в порядке полученных ими номерков, т.е. ведет себя как простой планировщик. Такая логика работы может конфликтовать с планировщиком операционной системы, у которого могут быть свои взгляды на порядок исполнения потоков.

Рассмотрим простой сценарий: в системе исполняются n потоков, каждый из них в бесконечном цикле выполняет короткую критическую секцию. Под короткой критической секцией будем понимать такой фрагмент кода, который можно много раз исполнить в течение одного кванта времени.

Утверждается, что с ростом числа потоков в какой-то момент частота исполнения критических секций (т.е. число критических секций в секунду) в системе очень сильно упадет.

1) При каком числе потоков это случится и почему?

2) Почему test-and-set spinlock не подвержен этой проблеме?

Будем предполагать следующий алгоритм поведения планировщика: каждому потоку выдается фиксированный квант времени на исполнение на процессоре, после чего выполнение потока прекращается, планировщик помещает его в хвост очереди на исполнение, а на освободившемся процессоре запускает поток из головы очереди.

void ticket_spinlock::lock() {
   const ticket_t this_thread_ticket = next_free_ticket_.fetch_add(1);
   while (this_thread_ticket != owner_ticket_.load()) {
       // wait
   }
}

void tas_spinlock::lock() {
   while (locked_.exchange(true)) {
       // wait
   }
}

Подсказка: подумайте, что будет, если поток встанет в очередь на ticket спинлоке, но будет вытеснен планировщиком.

Решение:

1) Действительно, если порядок потоков, предполагаемый планировщиком, противоположен порядку очереди.

Тогда каждый из потоков, стоящих в очереди, кроме самого первого, будут по очереди назначаться планирощиком на ядро и ждать квант времени, ничего не делая (даже если де-факто критическая секция пуста).

Например, пусть в системе используется (не самый эффективный, но существующий) планировщик Round-Robin, а мы случайно назначили тикеты в направлении обхода, противоположному RR.

Всё будет плохо.

Поскольку CS мала, то потеря одного кванта впустую очень существенна, т.е. частота выполнения CS падает значительно.

Про необходимое число тредов: кажется, что (пусть у нас 1 ядро) даже при 2 потоках может случиться такая беда.
Т.е. каждый второй квант времени управление даётся второму (в конце очереди) потоку, который безмолвно ждёт.
Тогда производительность упадёт уже в 2 раза.

2) В TAS-spinlock'e потокам всё равно, в каком порядке исполняться.

Поэтому как только очередной поток освободил крит.секцию, на его место встаёт другой (и здесь это определяется планировщиком системы без ущерба производительности).
